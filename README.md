# End-to-End DevOps Project: Spring PetClinic on EKS with GitOps, Istio & Monitoring

This repository demonstrates a production-grade DevOps workflow for deploying a Java Spring Boot application to AWS EKS. It implements Infrastructure as Code (IaC), GitOps, Service Mesh traffic management, and Observability.

## üèóÔ∏è Architecture Diagram

```mermaid
graph TD
    User([User]) -->|HTTPS| IGW[Internet Gateway]
    IGW --> ALB[AWS Load Balancer]
    ALB -->|Port 80| IG[Istio Ingress Gateway]
    
    subgraph EKS Cluster
        subgraph "Istio Service Mesh"
            IG -->|VirtualService (90%)| V1[PetClinic V1 Pods]
            IG -->|VirtualService (10%)| V2[PetClinic V2 Canary]
        end
        
        subgraph "Observability Stack"
            Prom[Prometheus] -->|Scrapes Metrics| V1
            Prom -->|Scrapes Metrics| V2
            Grafana[Grafana] -->|Queries| Prom
        end

        subgraph "GitOps Control Plane"
            Flux[Flux CD] -->|Pulls State| Git[GitHub Repo]
            Flux -->|Applies Manifests| K8sApi[K8s API]
        end
    end
    
    Dev[Developer] -->|Push Code| Git
    GA[GitHub Actions] -->|Build & Push Image| ECR[Amazon ECR]
    GA -->|Update Tag| Git
```

---

## üõ†Ô∏è Technology Stack & Justification

| Tool | Category | Why we chose it |
|------|----------|----------------|
| **Terraform** | IaC | Declarative infrastructure provisioning. Modular, state management, and provider ecosystem make it industry standard for AWS setup. |
| **AWS EKS** | Orchestration | Managed Kubernetes service. Offloads control plane management, high availability, and integrates natively with AWS VPC/IAM. |
| **Docker** | Containerization | Packages the Java app with all dependencies. Multi-stage builds ensure small, secure final images. |
| **Helm** | Packaging | "Package Manager" for K8s. Templatizes manifests (Deployment, Service) to handle different environments/versions easily. |
| **GitHub Actions** | CI System | Automates testing, building Docker images, and pushing to ECR. close integration with source code. |
| **Flux CD** | GitOps / CD | **Pull-based** deployment. Ensures the cluster state always matches Git. No direct access to cluster needed for CI. |
| **Istio** | Service Mesh | Manages traffic between services. Enables advanced rollout strategies like **Canary Deployments** (traffic splitting) without code changes. |
| **Prometheus** | Monitoring | Scrapes time-series metrics. Standard for K8s monitoring. |
| **Grafana** | Visualization | Visualizes Prometheus data. Provides rich dashboards for cluster and app health. |

---

## üìÇ Folder Structure & File Explanation

### 1. `Terraform/` (Infrastructure)
Defines the AWS infrastructure.

*   **`main.tf`**: The root configuration that calls all modules.
*   **`modules/`**: specific resource groupings.
    *   `vpc/`: Network setup (VPC, Subnets, Internet Gateway, NAT Gateway).
    *   `eks/`: Kubernetes cluster control plane and Node Groups.
    *   `ecr/`: Docker image registry.
*   **`backend/`**: Configures remote state storage (S3 + DynamoDB) to allow teamwork and state locking.

### 2. `app/` (Application Code)
The source code for Spring PetClinic.

*   **`Dockerfile`**: Defines how to build the app. Uses a multi-stage build:
    *   *Stage 1*: Maven build (compiles Java code).
    *   *Stage 2*: Run JRE (copies JAR from Stage 1). Result: Tiny image.
*   **`helm/petclinic/`**: The Helm chart definition.
    *   `templates/deployment.yaml`: Defines Pods. We updated this to allow dynamic `version` labels for Canary testing.
    *   `templates/service.yaml`: Defines the internal ClusterIP service.
    *   `values.yaml`: Default configuration (image repo, replica count, version).

### 3. `.github/workflows/deploy.yaml` (CI Pipeline)
Automates the Build ‚Üí Deploy loop.

*   **Triggers**: On push to `main` **only if files in `app/` change**. This prevents unnecessary builds when changing infrastructure or documentation.
*   **Jobs**:
    1.  Checkout code.
    2.  Login to AWS ECR.
    3.  Build Docker image & Push to ECR.
    4.  **Update Git**: Instead of running `kubectl apply`, it edits the `image.tag` in `clusters/myeks-cluster/petclinic-v2-release.yaml` and commits it back to the repo. This triggers Flux.

---

## üßπ Cleanup (Save Money!)

Since T3.small nodes and Load Balancers cost money, remember to destroy the infrastructure when done:

1.  **Delete Kubernetes LoadBalancers** (Terraform might wait forever if these still exist):
    ```bash
    kubectl delete svc --all -A
    ```
2.  **Destroy Infrastructure**:
    ```bash
    cd Terraform
    terraform destroy
    ```


### 4. `clusters/myeks-cluster/` (GitOps / Flux Configuration)
This is the "Truth" of what is running in the cluster.

#### **Infrastructure & Config**
*   **`flux-system/`**: Generated by `flux bootstrap`. Contains Flux controllers.

#### **Service Mesh (Istio)**
*   **`istio-repository.yaml`**: Points Flux to where Istio Helm charts live.
*   **`istio-base.yaml`**: Installs Istio CRDs (Custom Resource Definitions).
*   **`istiod.yaml`**: Installs the Control Plane. *Note: We reduced memory limits here to fit T3.small nodes.*
*   **`istio-gateway-release.yaml`**: Installs the **Istio Ingress Gateway** (the external Load Balancer).

#### **Application Deployment (Canary)**
*   **`petclinic-v1-release.yaml`**: Defines **Stable** version (90% traffic). Pinned to a specific image tag.
*   **`petclinic-v2-release.yaml`**: Defines **Canary** version (10% traffic). This file is automatically updated by GitHub Actions with new image tags.
*   **`petclinic-traffic.yaml`**: The Brains üß†. Contains:
    *   **VirtualService**: Rules saying "90% traffic to V1 subset, 10% to V2 subset".
    *   **DestinationRule**: Defines what "V1" (label `version: v1`) and "V2" (label `version: v2`) actually mean.
*   **`petclinic-gateway.yaml`**: Opens Port 80 on the Istio Ingress Gateway to allow traffic in.

#### **Observability**
*   **`prometheus-repository.yaml`**: Source for monitoring charts.
*   **`kube-prometheus-stack.yaml`**: Installs Prometheus, Grafana, Alertmanager.
*   **`petclinic-servicemonitor.yaml`**: Tells Prometheus "Please scrape metrics from PetClinic pods at `/actuator/prometheus`".

---

## üöÄ How It Works (The Flow)

1.  **Developer** changes code (e.g., "Welcome V3") and pushes to GitHub.
2.  **GitHub Action** builds new Docker image `tag: xyz` and pushes to ECR.
3.  **GitHub Action** edits `petclinic-v2-release.yaml` to use `tag: xyz` and commits.
4.  **Flux** (inside EKS) detects the commit.
5.  **Flux** upgrades `petclinic-v2` pods to the new image.
6.  **Istio** continues splitting traffic: 90% still see V1, 10% see the new V3 code.
7.  **Prometheus** scrapes metrics from both versions.
8.  **Grafana** displays health/performance data.

---

## üîß Useful Commands

### Check Flux Status
```bash
flux get helmreleases -A
flux resources source git flux-system
```

### Check Istio Traffic Split
```bash
# Get External URL
kubectl get svc -n istio-system istio-ingressgateway
```

### Access Grafana
```bash
# Get Admin Password
kubectl get secret -n monitoring monitoring-kube-prometheus-stack-grafana -o jsonpath="{.data.admin-password}" | base64 --decode
```

---

## ‚ö†Ô∏è Troubleshooting Guide / Lessons Learned

*   **OOMKilled**: Java apps need memory! Ensure resource limits are set correctly (`512Mi` for app).
*   **Pending Pods**: `t3.small` nodes have limit capacity. We scaled the Node Group to 3 nodes.
*   **Ghost Resources**: Flux might keep stale releases if files are renamed/moved improperly. Use `flux delete` if needed.
*   **CRD Race Conditions**: Use `dependsOn` in Flux HelmReleases to ensure CRDs (like ServiceMonitor) are installed before resources that use them.
